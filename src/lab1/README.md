# Лабораторная работа: Двухточечный обмен в MPJ

## Содержание
1. [Описание](#описание)
2. [Схема обмена](#схема-обмена)
3. [Реализация](#реализация)
4. [Анализ результатов](#анализ-результатов)
5. [Основные понятия MPJ](#основные-понятия-mpj)
6. [Типы реализаций обмена](#типы-реализаций-обмена)

## Описание

Данная лабораторная работа посвящена реализации двухточечного обмена сообщениями с использованием MPJ (MPI for Java). Цель работы - понять принципы параллельного программирования и обмена данными между процессами.

## Схема обмена

Анализируя исходный код, мы можем определить следующую схему обмена:

- Процессы с четным рангом (кроме последнего, если общее число процессов четное) отправляют сообщение процессу со следующим рангом.
- Процессы с нечетным рангом (кроме первого) получают сообщение от процесса с предыдущим рангом.

## Реализация

### Добавление вызовов процедур двухточечного обмена:

#### Для отправки сообщения (четные ранги):

```java
private static void sendMessage(int sender, int receiver) throws MPIException {
    int[] message = new int[]{sender};
    int tag = 0;
    printUTF8("Процесс " + sender + " начинает отправку сообщения процессу " + receiver);
    MPI.COMM_WORLD.Send(message, 0, 1, MPI.INT, receiver, tag);
    printUTF8("Процесс " + sender + " завершил отправку сообщения процессу " + receiver);
}
```

Объяснение параметров:
- `message` - массив для отправки
- `0` - начальный индекс в массиве
- `1` - количество элементов для отправки
- `MPI.INT` - тип данных
- `receiver` - ранг получателя
- `tag` - тег сообщения

#### Для получения сообщения (нечетные ранги):
```java
private static void receiveMessage(int receiver, int sender) throws MPIException {
    int[] message = new int;
    int tag = 0;
    printUTF8("Процесс " + receiver + " ожидает сообщение от процесса " + sender);
    MPI.COMM_WORLD.Recv(message, 0, 1, MPI.INT, sender, tag);
    printUTF8("Процесс " + receiver + " получил сообщение от процесса " + sender + ": " + message);
}
```

Объяснение параметров:
- `message` - массив для приема
- `0` - начальный индекс в массиве
- `1` - максимальное количество элементов для приема
- `MPI.INT` - тип данных
- `sender` - ранг отправителя
- `tag` - тег сообщения

Основная логика программы:
```java
public static void main(String[] args) {
    try {
        MPI.Init(args);
        int myRank = MPI.COMM_WORLD.Rank();
        int size = MPI.COMM_WORLD.Size();

        printUTF8("Процесс " + myRank + " запущен.");

        if (size % 2 != 0) {
            if (myRank == 0) {
                printUTF8("Ошибка: Необходимо четное количество процессов.");
            }
            return;
        }

        if (myRank % 2 == 0) {
            if (myRank + 1 < size) {
                sendMessage(myRank, myRank + 1);
            }
        } else {
            receiveMessage(myRank, myRank - 1);
        }

        printUTF8("Процесс " + myRank + " завершил работу.");
    } catch (MPIException e) {
        System.err.println("MPI ошибка: " + e.getMessage());
    } finally {
        MPI.Finalize();
    }
}
```

Основная логика программы:
java
public static void main(String[] args) {
try {
MPI.Init(args);
int myRank = MPI.COMM_WORLD.Rank();
int size = MPI.COMM_WORLD.Size();

        printUTF8("Процесс " + myRank + " запущен.");

        if (size % 2 != 0) {
            if (myRank == 0) {
                printUTF8("Ошибка: Необходимо четное количество процессов.");
            }
            return;
        }

        if (myRank % 2 == 0) {
            if (myRank + 1 < size) {
                sendMessage(myRank, myRank + 1);
            }
        } else {
            receiveMessage(myRank, myRank - 1);
        }

        printUTF8("Процесс " + myRank + " завершил работу.");
    } catch (MPIException e) {
        System.err.println("MPI ошибка: " + e.getMessage());
    } finally {
        MPI.Finalize();
    }
}

Объяснение основной логики:
- Инициализация MPI среды
- Получение ранга текущего процесса и общего количества процессов
- Проверка на четное количество процессов
- Четные процессы отправляют сообщения, нечетные - получают
- Обработка ошибок MPI
- Завершение MPI среды в блоке `finally`

Дополнительно реализована функция `printUTF8` для корректного вывода кириллицы:
```java
private static void printUTF8(String message) {
    System.out.println(new String(message.getBytes(StandardCharsets.UTF_8), StandardCharsets.UTF_8));
}
```
Эта функция обеспечивает правильное отображение русских символов в консоли.


## Анализ результатов
После запуска программы с четным числом процессов (например, 4), вы должны увидеть вывод, подобный этому:
```text
Процесс 0 запущен.
Процесс 1 запущен.
Процесс 2 запущен.
Процесс 3 запущен.
Процесс 0 начинает отправку сообщения процессу 1
Процесс 0 завершил отправку сообщения процессу 1
Процесс 2 начинает отправку сообщения процессу 3
Процесс 2 завершил отправку сообщения процессу 3
Процесс 1 ожидает сообщение от процесса 0
Процесс 1 получил сообщение от процесса 0: 0
Процесс 3 ожидает сообщение от процесса 2
Процесс 3 получил сообщение от процесса 2: 2
Процесс 0 завершил работу.
Процесс 1 завершил работу.
Процесс 2 завершил работу.
Процесс 3 завершил работу.
```

Это показывает, что:
- Процессы 0 и 2 успешно отправили свои сообщения
- Процессы 1 и 3 успешно получили сообщения
- Обмен данными произошел согласно заданной схеме

## Основные понятия MPJ
- **Процесс**: Независимая единица выполнения в параллельной программе.
- **Ранг**: Уникальный идентификатор процесса в группе.
- **Коммуникатор**: Группа процессов, которые могут обмениваться сообщениями.
- **Сообщение**: Данные, передаваемые между процессами.
- **Тег**: Идентификатор, используемый для различения сообщений.

## Типы реализаций обмена
- **Двухточечный обмен (Point-to-Point)**: Обмен данными между двумя конкретными процессами.
- **Коллективный обмен (Collective Communication)**: Обмен данными, включающий все процессы в группе.
- **Кольцевой обмен (Ring Communication)**: Процессы обмениваются данными в кольцевой топологии.
- **Широковещательная рассылка (Broadcast)**: Один процесс отправляет данные всем остальным.
- **Распределение данных (Scatter)**: Распределение частей данных от одного процесса всем остальным.
- **Сбор данных (Gather)**: Сбор данных от всех процессов в один.